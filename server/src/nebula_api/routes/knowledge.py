"""Knowledge API routes."""

# Standard Library
from pathlib import Path
from typing import Any
from uuid import UUID

# Third-Party
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, field_validator

# Local
from nebula_api.auth import maybe_check_agent_approval, require_auth
from nebula_api.response import paginated, success
from nebula_mcp.enums import require_status
from nebula_mcp.executors import execute_create_knowledge, execute_create_relationship
from nebula_mcp.helpers import (
    enforce_scope_subset,
    filter_context_segments,
    scope_names_from_ids,
)
from nebula_mcp.models import MAX_PAGE_LIMIT, MAX_TAG_LENGTH, MAX_TAGS
from nebula_mcp.query_loader import QueryLoader

QUERIES = QueryLoader(Path(__file__).resolve().parents[2] / "queries")

router = APIRouter()
ADMIN_SCOPE_NAMES = {"vault-only", "sensitive"}


def _is_admin(auth: dict, enums: Any) -> bool:
    scope_ids = set(auth.get("scopes", []))
    allowed_ids = {
        enums.scopes.name_to_id.get(name)
        for name in ADMIN_SCOPE_NAMES
        if enums.scopes.name_to_id.get(name)
    }
    return bool(scope_ids.intersection(allowed_ids))


def _has_write_scopes(agent_scopes: list, node_scopes: list) -> bool:
    if not node_scopes:
        return True
    if not agent_scopes:
        return False
    return set(node_scopes).issubset(set(agent_scopes))


async def _require_entity_write_access(
    pool: Any, enums: Any, auth: dict, entity_id: str
) -> None:
    if auth["caller_type"] != "agent":
        return
    if _is_admin(auth, enums):
        return
    row = await pool.fetchrow(QUERIES["entities/get"], entity_id)
    if not row:
        raise HTTPException(status_code=404, detail="Not Found")
    if not _has_write_scopes(
        auth.get("scopes", []), row.get("privacy_scope_ids") or []
    ):
        raise HTTPException(status_code=403, detail="Forbidden")


async def _require_knowledge_write_access(
    pool: Any, enums: Any, auth: dict, knowledge_id: str
) -> None:
    if auth["caller_type"] != "agent":
        return
    if _is_admin(auth, enums):
        return
    row = await pool.fetchrow(QUERIES["knowledge/get"], knowledge_id, None)
    if not row:
        raise HTTPException(status_code=404, detail="Not Found")
    if not _has_write_scopes(
        auth.get("scopes", []), row.get("privacy_scope_ids") or []
    ):
        raise HTTPException(status_code=403, detail="Forbidden")


def _validate_tag_list(tags: list[str] | None) -> list[str] | None:
    if tags is None:
        return None
    cleaned = [t.strip() for t in tags if t and t.strip()]
    if len(cleaned) > MAX_TAGS:
        raise ValueError("Too many tags")
    for tag in cleaned:
        if len(tag) > MAX_TAG_LENGTH:
            raise ValueError("Tag too long")
    return cleaned


class CreateKnowledgeBody(BaseModel):
    """Payload for creating a knowledge item.

    Attributes:
        title: Knowledge title.
        url: Optional URL.
        source_type: Knowledge source type.
        content: Optional content text.
        scopes: Privacy scopes.
        tags: Tag list.
        metadata: Arbitrary metadata.
    """

    title: str
    url: str | None = None
    source_type: str = "article"
    content: str | None = None
    scopes: list[str] = []
    tags: list[str] = []
    metadata: dict | None = None

    @field_validator("tags", mode="before")
    @classmethod
    def _clean_tags(cls, v: list[str] | None) -> list[str] | None:
        return _validate_tag_list(v)

    @field_validator("url", mode="before")
    @classmethod
    def _validate_url(cls, v: str | None) -> str | None:
        if not v:
            return v
        v = v.strip()
        if not (v.startswith("http://") or v.startswith("https://")):
            raise ValueError("URL must start with http:// or https://")
        return v


class LinkKnowledgeBody(BaseModel):
    """Payload for linking knowledge to an entity.

    Attributes:
        entity_id: Target entity id.
        relationship_type: Relationship type name.
    """

    entity_id: str
    relationship_type: str = "related-to"


class UpdateKnowledgeBody(BaseModel):
    """Payload for updating a knowledge item.

    Attributes:
        title: Updated title.
        url: Updated URL.
        source_type: Updated source type.
        content: Updated content.
        status: Updated status name.
        tags: Updated tags.
        scopes: Updated scopes.
        metadata: Updated metadata.
    """

    title: str | None = None
    url: str | None = None
    source_type: str | None = None
    content: str | None = None
    status: str | None = None
    tags: list[str] | None = None
    scopes: list[str] | None = None
    metadata: dict | None = None

    @field_validator("tags", mode="before")
    @classmethod
    def _clean_tags(cls, v: list[str] | None) -> list[str] | None:
        return _validate_tag_list(v)

    @field_validator("url", mode="before")
    @classmethod
    def _validate_url(cls, v: str | None) -> str | None:
        if not v:
            return v
        v = v.strip()
        if not (v.startswith("http://") or v.startswith("https://")):
            raise ValueError("URL must start with http:// or https://")
        return v


@router.post("/")
async def create_knowledge(
    payload: CreateKnowledgeBody,
    request: Request,
    auth: dict = Depends(require_auth),
) -> dict[str, Any]:
    """Create a knowledge item.

    Args:
        payload: Knowledge creation payload.
        request: FastAPI request.
        auth: Auth context.

    Returns:
        API response with created knowledge or approval requirement.
    """
    pool = request.app.state.pool
    enums = request.app.state.enums
    data = payload.model_dump()
    data.setdefault("metadata", {})
    if data["metadata"] is None:
        data["metadata"] = {}
    if auth["caller_type"] == "agent":
        allowed = scope_names_from_ids(auth.get("scopes", []), enums)
        data["scopes"] = enforce_scope_subset(data["scopes"], allowed)
    if resp := await maybe_check_agent_approval(pool, auth, "create_knowledge", data):
        return resp
    result = await execute_create_knowledge(pool, enums, data)
    return success(result)


@router.get("/")
async def query_knowledge(
    request: Request,
    auth: dict = Depends(require_auth),
    source_type: str | None = None,
    tags: str | None = None,
    search_text: str | None = None,
    limit: int = Query(50, le=MAX_PAGE_LIMIT),
    offset: int = 0,
) -> dict[str, Any]:
    """Query knowledge items with filters.

    Args:
        request: FastAPI request.
        auth: Auth context.
        source_type: Source type filter.
        tags: Comma-separated tag filters.
        search_text: Full-text search filter.
        limit: Max rows.
        offset: Offset for pagination.

    Returns:
        Paginated API response with knowledge items.
    """
    pool = request.app.state.pool
    scope_ids = auth.get("scopes", [])
    tag_list = tags.split(",") if tags else None

    rows = await pool.fetch(
        QUERIES["knowledge/query"],
        source_type,
        tag_list,
        search_text,
        scope_ids,
        limit,
        offset,
    )
    scope_names = scope_names_from_ids(scope_ids, request.app.state.enums)
    results = []
    for row in rows:
        item = dict(row)
        if item.get("metadata"):
            item["metadata"] = filter_context_segments(item["metadata"], scope_names)
        results.append(item)
    return paginated(results, len(results), limit, offset)


@router.get("/{knowledge_id}")
async def get_knowledge(
    knowledge_id: str,
    request: Request,
    auth: dict = Depends(require_auth),
) -> dict[str, Any]:
    """Fetch a knowledge item by id.

    Args:
        knowledge_id: Knowledge id.
        request: FastAPI request.
        auth: Auth context.

    Returns:
        API response with knowledge data.
    """
    pool = request.app.state.pool
    scope_ids = auth.get("scopes", [])
    try:
        UUID(knowledge_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid knowledge id")
    row = await pool.fetchrow(
        QUERIES["knowledge/get"],
        knowledge_id,
        scope_ids,
    )
    if not row:
        raise HTTPException(status_code=404, detail="Not Found")
    item = dict(row)
    if item.get("metadata"):
        scope_names = scope_names_from_ids(scope_ids, request.app.state.enums)
        item["metadata"] = filter_context_segments(item["metadata"], scope_names)
    return success(item)


@router.post("/{knowledge_id}/link")
async def link_to_entity(
    knowledge_id: str,
    payload: LinkKnowledgeBody,
    request: Request,
    auth: dict = Depends(require_auth),
) -> dict[str, Any]:
    """Create a relationship from knowledge to an entity.

    Args:
        knowledge_id: Knowledge id.
        payload: Link payload.
        request: FastAPI request.
        auth: Auth context.

    Returns:
        API response with created relationship or approval requirement.
    """
    pool = request.app.state.pool
    enums = request.app.state.enums
    try:
        UUID(knowledge_id)
        UUID(payload.entity_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid id")
    await _require_knowledge_write_access(pool, enums, auth, knowledge_id)
    await _require_entity_write_access(pool, enums, auth, payload.entity_id)
    relationship_payload = {
        "source_type": "knowledge",
        "source_id": knowledge_id,
        "target_type": "entity",
        "target_id": payload.entity_id,
        "relationship_type": payload.relationship_type,
        "properties": {},
    }
    if resp := await maybe_check_agent_approval(
        pool, auth, "create_relationship", relationship_payload
    ):
        return resp

    result = await execute_create_relationship(pool, enums, relationship_payload)
    return success(result)


@router.patch("/{knowledge_id}")
async def update_knowledge(
    knowledge_id: str,
    payload: UpdateKnowledgeBody,
    request: Request,
    auth: dict = Depends(require_auth),
) -> dict[str, Any]:
    """Update a knowledge item.

    Args:
        knowledge_id: Knowledge id.
        payload: Knowledge update payload.
        request: FastAPI request.
        auth: Auth context.

    Returns:
        API response with updated knowledge or approval requirement.
    """
    pool = request.app.state.pool
    enums = request.app.state.enums
    try:
        UUID(knowledge_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid knowledge id")

    await _require_knowledge_write_access(pool, enums, auth, knowledge_id)

    data = payload.model_dump()
    status_id = None
    if data.get("status"):
        status_id = require_status(data["status"], enums)
    if data.get("metadata") is None:
        data.pop("metadata", None)
    if auth["caller_type"] == "agent" and data.get("scopes") is not None:
        allowed = scope_names_from_ids(auth.get("scopes", []), enums)
        data["scopes"] = enforce_scope_subset(data["scopes"], allowed)
    change = {"knowledge_id": knowledge_id, **data}
    if resp := await maybe_check_agent_approval(pool, auth, "update_knowledge", change):
        return resp
    row = await pool.fetchrow(
        QUERIES["knowledge/update"],
        knowledge_id,
        data.get("title"),
        data.get("url"),
        data.get("source_type"),
        data.get("content"),
        status_id,
        data.get("tags"),
        data.get("scopes"),
        data.get("metadata"),
    )
    if not row:
        raise HTTPException(status_code=404, detail="Not Found")
    return success(dict(row))
