package ui

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"github.com/gravitrone/nebula-core/cli/internal/api"
	"github.com/gravitrone/nebula-core/cli/internal/ui/components"
)

type searchResultsMsg struct {
	query     string
	mode      string
	entities  []api.Entity
	knowledge []api.Knowledge
	jobs      []api.Job
	semantic  []api.SemanticSearchResult
}

type searchSelectionMsg struct {
	kind      string
	entity    *api.Entity
	knowledge *api.Knowledge
	job       *api.Job
}

type searchEntry struct {
	kind      string
	id        string
	label     string
	desc      string
	entity    *api.Entity
	knowledge *api.Knowledge
	job       *api.Job
}

type SearchModel struct {
	client  *api.Client
	query   string
	mode    string
	loading bool
	list    *components.List
	items   []searchEntry
	width   int
	height  int
}

const (
	searchModeText     = "text"
	searchModeSemantic = "semantic"
)

// NewSearchModel builds the search UI model.
func NewSearchModel(client *api.Client) SearchModel {
	return SearchModel{
		client: client,
		mode:   searchModeText,
		list:   components.NewList(12),
	}
}

func (m SearchModel) Init() tea.Cmd {
	return nil
}

func (m SearchModel) Update(msg tea.Msg) (SearchModel, tea.Cmd) {
	switch msg := msg.(type) {
	case searchResultsMsg:
		if strings.TrimSpace(msg.query) != strings.TrimSpace(m.query) {
			return m, nil
		}
		if msg.mode != m.mode {
			return m, nil
		}
		m.loading = false
		if m.mode == searchModeSemantic {
			m.items = buildSemanticEntries(msg.semantic)
		} else {
			m.items = buildSearchEntries(msg.query, msg.entities, msg.knowledge, msg.jobs)
		}
		labels := make([]string, len(m.items))
		for i, item := range m.items {
			labels[i] = fmt.Sprintf(
				"%s  %s",
				components.SanitizeText(item.label),
				MutedStyle.Render(components.SanitizeText(item.desc)),
			)
		}
		m.list.SetItems(labels)
		return m, nil
	case tea.KeyMsg:
		switch {
		case isBack(msg):
			if m.query != "" {
				m.query = ""
				m.items = nil
				m.list.SetItems(nil)
				m.loading = false
				return m, nil
			}
		case isKey(msg, "cmd+backspace", "cmd+delete", "ctrl+u"):
			if m.query != "" {
				m.query = ""
				m.items = nil
				m.list.SetItems(nil)
				m.loading = false
				return m, nil
			}
		case isKey(msg, "backspace", "delete"):
			if len(m.query) > 0 {
				m.query = m.query[:len(m.query)-1]
				return m, m.search(m.query)
			}
		case isDown(msg):
			m.list.Down()
		case isUp(msg):
			m.list.Up()
		case isKey(msg, "tab"):
			if m.mode == searchModeText {
				m.mode = searchModeSemantic
			} else {
				m.mode = searchModeText
			}
			if strings.TrimSpace(m.query) == "" {
				m.loading = false
				m.items = nil
				m.list.SetItems(nil)
				return m, nil
			}
			return m, m.search(m.query)
		case isEnter(msg):
			if idx := m.list.Selected(); idx < len(m.items) {
				entry := m.items[idx]
				return m, m.emitSelection(entry)
			}
		default:
			ch := msg.String()
			if len(ch) == 1 || ch == " " {
				if ch == " " && m.query == "" {
					return m, nil
				}
				m.query += ch
				return m, m.search(m.query)
			}
		}
	}
	return m, nil
}

func (m SearchModel) View() string {
	var b strings.Builder
	b.WriteString(MutedStyle.Render(fmt.Sprintf("Mode: %s (tab to toggle)", m.mode)))
	b.WriteString("\n\n")
	query := components.SanitizeText(m.query)
	queryWidth := components.BoxContentWidth(m.width) - 8
	if queryWidth < 10 {
		queryWidth = 10
	}
	query = components.ClampTextWidthEllipsis(query, queryWidth)
	b.WriteString(MetaKeyStyle.Render("Query") + MetaPunctStyle.Render(": ") + SelectedStyle.Render(query))
	b.WriteString(AccentStyle.Render("█"))
	b.WriteString("\n\n")

	if m.loading {
		b.WriteString(MutedStyle.Render("Searching..."))
	} else if strings.TrimSpace(m.query) == "" {
		b.WriteString(MutedStyle.Render("Type to search."))
	} else if len(m.items) == 0 {
		b.WriteString(MutedStyle.Render("No matches."))
	} else {
		contentWidth := components.BoxContentWidth(m.width)
		visible := m.list.Visible()

		previewWidth := contentWidth * 35 / 100
		if previewWidth < 40 {
			previewWidth = 40
		}
		if previewWidth > 60 {
			previewWidth = 60
		}

		gap := 3
		tableWidth := contentWidth
		sideBySide := contentWidth >= 110
		if sideBySide {
			tableWidth = contentWidth - previewWidth - gap
			if tableWidth < 60 {
				sideBySide = false
				tableWidth = contentWidth
			}
		}

		sepWidth := 1
		if br := lipgloss.RoundedBorder().Left; br != "" {
			sepWidth = lipgloss.Width(br)
		}

		// 3 columns -> 2 separators.
		availableCols := tableWidth - (2 * sepWidth)
		if availableCols < 30 {
			availableCols = 30
		}

		kindWidth := 10
		infoWidth := 28
		titleWidth := availableCols - (kindWidth + infoWidth)
		if titleWidth < 16 {
			titleWidth = 16
			infoWidth = availableCols - (titleWidth + kindWidth)
			if infoWidth < 14 {
				infoWidth = 14
			}
		}

		cols := []components.TableColumn{
			{Header: "Title", Width: titleWidth, Align: lipgloss.Left},
			{Header: "Kind", Width: kindWidth, Align: lipgloss.Left},
			{Header: "Info", Width: infoWidth, Align: lipgloss.Left},
		}

		tableRows := make([][]string, 0, len(visible))
		activeRowRel := -1
		var previewItem *searchEntry
		if idx := m.list.Selected(); idx >= 0 && idx < len(m.items) {
			previewItem = &m.items[idx]
		}

		for i := range visible {
			absIdx := m.list.RelToAbs(i)
			if absIdx < 0 || absIdx >= len(m.items) {
				continue
			}
			entry := m.items[absIdx]

			kind := strings.TrimSpace(components.SanitizeOneLine(entry.kind))
			if kind == "" {
				kind = "-"
			}
			title := strings.TrimSpace(components.SanitizeOneLine(entry.label))
			if title == "" {
				title = "-"
			}
			info := strings.TrimSpace(components.SanitizeOneLine(entry.desc))
			if info == "" {
				info = "-"
			}

			if m.list.IsSelected(absIdx) {
				activeRowRel = len(tableRows)
			}

			tableRows = append(tableRows, []string{
				components.ClampTextWidthEllipsis(title, titleWidth),
				components.ClampTextWidthEllipsis(kind, kindWidth),
				components.ClampTextWidthEllipsis(info, infoWidth),
			})
		}

		countLine := MutedStyle.Render(fmt.Sprintf("%d results", len(m.items)))
		table := components.TableGridWithActiveRow(cols, tableRows, tableWidth, activeRowRel)
		preview := ""
		if previewItem != nil {
			content := m.renderSearchPreview(*previewItem, previewBoxContentWidth(previewWidth))
			preview = renderPreviewBox(content, previewWidth)
		}

		body := table
		if sideBySide && preview != "" {
			body = lipgloss.JoinHorizontal(lipgloss.Top, table, strings.Repeat(" ", gap), preview)
		} else if preview != "" {
			body = table + "\n\n" + preview
		}

		b.WriteString(countLine)
		b.WriteString("\n\n")
		b.WriteString(body)
	}

	return components.Indent(components.TitledBox("Search", b.String(), m.width), 1)
}

func (m SearchModel) renderSearchPreview(entry searchEntry, width int) string {
	if width <= 0 {
		return ""
	}

	title := strings.TrimSpace(components.SanitizeOneLine(entry.label))
	if title == "" {
		title = "result"
	}

	var lines []string
	lines = append(lines, MetaKeyStyle.Render("Selected"))
	for _, part := range wrapPreviewText(title, width) {
		lines = append(lines, SelectedStyle.Render(part))
	}
	lines = append(lines, "")

	kind := strings.TrimSpace(components.SanitizeOneLine(entry.kind))
	if kind == "" {
		kind = "-"
	}
	lines = append(lines, renderPreviewRow("Kind", kind, width))
	if strings.TrimSpace(entry.id) != "" {
		lines = append(lines, renderPreviewRow("ID", shortID(entry.id), width))
	}
	if strings.TrimSpace(entry.desc) != "" {
		lines = append(lines, renderPreviewRow("Info", entry.desc, width))
	}

	if entry.entity != nil {
		typ := strings.TrimSpace(components.SanitizeOneLine(entry.entity.Type))
		if typ != "" {
			lines = append(lines, renderPreviewRow("Type", typ, width))
		}
		status := strings.TrimSpace(components.SanitizeOneLine(entry.entity.Status))
		if status != "" {
			lines = append(lines, renderPreviewRow("Status", status, width))
		}
		if len(entry.entity.Tags) > 0 {
			lines = append(lines, renderPreviewRow("Tags", strings.Join(entry.entity.Tags, ", "), width))
		}
	} else if entry.knowledge != nil {
		src := strings.TrimSpace(components.SanitizeOneLine(entry.knowledge.SourceType))
		if src != "" {
			lines = append(lines, renderPreviewRow("Source", src, width))
		}
		status := strings.TrimSpace(components.SanitizeOneLine(entry.knowledge.Status))
		if status != "" {
			lines = append(lines, renderPreviewRow("Status", status, width))
		}
		if entry.knowledge.URL != nil && strings.TrimSpace(*entry.knowledge.URL) != "" {
			lines = append(lines, renderPreviewRow("URL", strings.TrimSpace(*entry.knowledge.URL), width))
		}
		if len(entry.knowledge.Tags) > 0 {
			lines = append(lines, renderPreviewRow("Tags", strings.Join(entry.knowledge.Tags, ", "), width))
		}
		if snippet := previewStringValue(entry.knowledge.Metadata, "snippet"); snippet != "" {
			lines = append(lines, renderPreviewRow("Snippet", snippet, width))
		}
	} else if entry.job != nil {
		status := strings.TrimSpace(components.SanitizeOneLine(entry.job.Status))
		if status != "" {
			lines = append(lines, renderPreviewRow("Status", status, width))
		}
		if entry.job.Priority != nil && strings.TrimSpace(*entry.job.Priority) != "" {
			lines = append(lines, renderPreviewRow("Priority", strings.TrimSpace(*entry.job.Priority), width))
		}
		if metaPreview := metadataPreview(map[string]any(entry.job.Metadata), 80); metaPreview != "" {
			lines = append(lines, renderPreviewRow("Meta", metaPreview, width))
		}
	}

	return padPreviewLines(lines, width)
}

func (m *SearchModel) search(query string) tea.Cmd {
	q := strings.TrimSpace(query)
	if q == "" {
		m.loading = false
		m.items = nil
		m.list.SetItems(nil)
		return nil
	}
	m.loading = true
	mode := m.mode
	return func() tea.Msg {
		if mode == searchModeSemantic {
			results, err := m.client.SemanticSearch(q, []string{"entity", "knowledge"}, 20)
			if err != nil {
				return errMsg{err}
			}
			return searchResultsMsg{
				query:    q,
				mode:     mode,
				semantic: results,
			}
		}
		entities, err := m.client.QueryEntities(api.QueryParams{
			"search_text": q,
			"limit":       "20",
		})
		if err != nil {
			return errMsg{err}
		}
		knowledge, err := m.client.QueryKnowledge(api.QueryParams{
			"search_text": q,
			"limit":       "20",
		})
		if err != nil {
			return errMsg{err}
		}
		jobs, err := m.client.QueryJobs(api.QueryParams{
			"search_text": q,
			"limit":       "20",
		})
		if err != nil {
			return errMsg{err}
		}
		return searchResultsMsg{
			query:     q,
			mode:      mode,
			entities:  filterEntitiesByQuery(entities, q),
			knowledge: filterKnowledgeByQuery(knowledge, q),
			jobs:      filterJobsByQuery(jobs, q),
		}
	}
}

func (m SearchModel) emitSelection(entry searchEntry) tea.Cmd {
	return func() tea.Msg {
		switch entry.kind {
		case "entity":
			if entry.entity == nil {
				item, err := m.client.GetEntity(entry.id)
				if err != nil {
					return errMsg{err}
				}
				return searchSelectionMsg{kind: entry.kind, entity: item}
			}
		case "knowledge":
			if entry.knowledge == nil {
				item, err := m.client.GetKnowledge(entry.id)
				if err != nil {
					return errMsg{err}
				}
				return searchSelectionMsg{kind: entry.kind, knowledge: item}
			}
		case "job":
			if entry.job == nil {
				item, err := m.client.GetJob(entry.id)
				if err != nil {
					return errMsg{err}
				}
				return searchSelectionMsg{kind: entry.kind, job: item}
			}
		}
		return searchSelectionMsg{
			kind:      entry.kind,
			entity:    entry.entity,
			knowledge: entry.knowledge,
			job:       entry.job,
		}
	}
}

func buildSemanticEntries(items []api.SemanticSearchResult) []searchEntry {
	out := make([]searchEntry, 0, len(items))
	for _, item := range items {
		title := strings.TrimSpace(item.Title)
		if title == "" {
			title = item.ID
		}
		descParts := []string{
			fmt.Sprintf("%.2f", item.Score),
		}
		if strings.TrimSpace(item.Subtitle) != "" {
			descParts = append(descParts, item.Subtitle)
		}
		if strings.TrimSpace(item.Snippet) != "" {
			descParts = append(descParts, item.Snippet)
		}
		out = append(out, searchEntry{
			kind:  item.Kind,
			id:    item.ID,
			label: components.SanitizeText(title),
			desc:  components.SanitizeText(strings.Join(descParts, " · ")),
		})
	}
	return out
}

func buildSearchEntries(query string, entities []api.Entity, knowledge []api.Knowledge, jobs []api.Job) []searchEntry {
	items := make([]searchEntry, 0, len(entities)+len(knowledge)+len(jobs))
	for _, e := range entities {
		kind := "entity"
		descType := e.Type
		if descType == "" {
			descType = "entity"
		}
		entity := e
		items = append(items, searchEntry{
			kind:   kind,
			id:     e.ID,
			label:  components.SanitizeText(e.Name),
			desc:   components.SanitizeText(fmt.Sprintf("%s · %s", descType, shortID(e.ID))),
			entity: &entity,
		})
	}
	for _, k := range knowledge {
		kind := "knowledge"
		descType := k.SourceType
		if descType == "" {
			descType = "knowledge"
		}
		knowledgeItem := k
		items = append(items, searchEntry{
			kind:      kind,
			id:        k.ID,
			label:     components.SanitizeText(k.Name),
			desc:      components.SanitizeText(fmt.Sprintf("%s · %s", descType, shortID(k.ID))),
			knowledge: &knowledgeItem,
		})
	}
	for _, j := range jobs {
		kind := "job"
		desc := j.Status
		if desc == "" {
			desc = "job"
		}
		job := j
		items = append(items, searchEntry{
			kind:  kind,
			id:    j.ID,
			label: components.SanitizeText(j.Title),
			desc:  components.SanitizeText(fmt.Sprintf("%s · %s", desc, shortID(j.ID))),
			job:   &job,
		})
	}
	return items
}

func filterEntitiesByQuery(items []api.Entity, query string) []api.Entity {
	q := strings.ToLower(strings.TrimSpace(query))
	if q == "" {
		return items
	}
	out := make([]api.Entity, 0, len(items))
	for _, e := range items {
		name, typ := normalizeEntityNameType(e.Name, e.Type)
		haystack := strings.ToLower(strings.Join([]string{name, typ, e.ID}, " "))
		if strings.Contains(haystack, q) {
			out = append(out, e)
		}
	}
	return out
}

func filterKnowledgeByQuery(items []api.Knowledge, query string) []api.Knowledge {
	q := strings.ToLower(strings.TrimSpace(query))
	if q == "" {
		return items
	}
	out := make([]api.Knowledge, 0, len(items))
	for _, k := range items {
		if strings.Contains(strings.ToLower(k.Name), q) || strings.Contains(strings.ToLower(k.ID), q) {
			out = append(out, k)
		}
	}
	return out
}

func filterJobsByQuery(items []api.Job, query string) []api.Job {
	q := strings.ToLower(strings.TrimSpace(query))
	if q == "" {
		return items
	}
	out := make([]api.Job, 0, len(items))
	for _, j := range items {
		if strings.Contains(strings.ToLower(j.Title), q) || strings.Contains(strings.ToLower(j.ID), q) {
			out = append(out, j)
		}
	}
	return out
}
