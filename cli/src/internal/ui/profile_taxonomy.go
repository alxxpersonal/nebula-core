package ui

import (
	"fmt"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"github.com/gravitrone/nebula-core/cli/internal/api"
	"github.com/gravitrone/nebula-core/cli/internal/ui/components"
)

type taxonomyLoadedMsg struct {
	kind  string
	items []api.TaxonomyEntry
}

type taxonomyActionDoneMsg struct{}

type taxonomyPromptMode int

const (
	taxPromptNone taxonomyPromptMode = iota
	taxPromptCreateName
	taxPromptCreateDescription
	taxPromptEditName
	taxPromptEditDescription
	taxPromptFilter
)

var taxonomyKinds = []struct {
	Label string
	Path  string
}{
	{Label: "Scopes", Path: "scopes"},
	{Label: "Entity Types", Path: "entity-types"},
	{Label: "Relationship Types", Path: "relationship-types"},
	{Label: "Log Types", Path: "log-types"},
}

func (m ProfileModel) taxonomyKindPath() string {
	if m.taxKind < 0 || m.taxKind >= len(taxonomyKinds) {
		return taxonomyKinds[0].Path
	}
	return taxonomyKinds[m.taxKind].Path
}

func (m ProfileModel) loadTaxonomy() tea.Msg {
	kind := m.taxonomyKindPath()
	items, err := m.client.ListTaxonomy(kind, m.taxIncludeInactive, m.taxSearch, 200, 0)
	if err != nil {
		return errMsg{err}
	}
	return taxonomyLoadedMsg{kind: kind, items: items}
}

func (m *ProfileModel) setTaxonomyItems(items []api.TaxonomyEntry) {
	m.taxItems = items
	labels := make([]string, len(items))
	for i, item := range items {
		labels[i] = formatTaxonomyLine(item)
	}
	m.taxList.SetItems(labels)
}

func formatTaxonomyLine(item api.TaxonomyEntry) string {
	name := components.SanitizeOneLine(item.Name)
	parts := []string{name}
	if item.IsBuiltin {
		parts = append(parts, TypeBadgeStyle.Render("builtin"))
	}
	if !item.IsActive {
		parts = append(parts, WarningStyle.Render("inactive"))
	}
	if item.Description != nil && strings.TrimSpace(*item.Description) != "" {
		parts = append(parts, MutedStyle.Render(components.SanitizeOneLine(*item.Description)))
	}
	return strings.Join(parts, "  ")
}

func (m ProfileModel) selectedTaxonomy() *api.TaxonomyEntry {
	if m.taxList == nil {
		return nil
	}
	idx := m.taxList.Selected()
	if idx < 0 || idx >= len(m.taxItems) {
		return nil
	}
	item := m.taxItems[idx]
	return &item
}

func (m *ProfileModel) openTaxPrompt(mode taxonomyPromptMode, defaultValue string) {
	m.taxPromptMode = mode
	m.taxPromptBuf = defaultValue
}

func (m ProfileModel) taxonomyPromptTitle() string {
	switch m.taxPromptMode {
	case taxPromptCreateName:
		return "New Taxonomy Name"
	case taxPromptCreateDescription:
		return "New Taxonomy Description (optional)"
	case taxPromptEditName:
		return "Edit Taxonomy Name"
	case taxPromptEditDescription:
		return "Edit Taxonomy Description (optional)"
	case taxPromptFilter:
		return "Taxonomy Filter"
	default:
		return "Taxonomy"
	}
}

func (m ProfileModel) handleTaxonomyPrompt(msg tea.KeyMsg) (ProfileModel, tea.Cmd) {
	switch {
	case isBack(msg):
		m.taxPromptMode = taxPromptNone
		m.taxPromptBuf = ""
		m.taxPendingName = ""
		m.taxPendingDesc = ""
		m.taxEditID = ""
		return m, nil
	case isEnter(msg):
		return m.submitTaxonomyPrompt()
	case isKey(msg, "backspace"):
		if len(m.taxPromptBuf) > 0 {
			m.taxPromptBuf = m.taxPromptBuf[:len(m.taxPromptBuf)-1]
		}
		return m, nil
	default:
		if len(msg.String()) == 1 || msg.String() == " " {
			m.taxPromptBuf += msg.String()
		}
		return m, nil
	}
}

func (m ProfileModel) submitTaxonomyPrompt() (ProfileModel, tea.Cmd) {
	switch m.taxPromptMode {
	case taxPromptCreateName:
		name := strings.TrimSpace(m.taxPromptBuf)
		if name == "" {
			m.taxPromptMode = taxPromptNone
			m.taxPromptBuf = ""
			return m, func() tea.Msg { return errMsg{fmt.Errorf("taxonomy name required")} }
		}
		m.taxPendingName = name
		m.openTaxPrompt(taxPromptCreateDescription, "")
		return m, nil
	case taxPromptCreateDescription:
		desc := strings.TrimSpace(m.taxPromptBuf)
		input := api.CreateTaxonomyInput{
			Name:        m.taxPendingName,
			Description: desc,
		}
		kind := m.taxonomyKindPath()
		m.taxPromptMode = taxPromptNone
		m.taxPromptBuf = ""
		m.taxPendingName = ""
		m.taxPendingDesc = ""
		m.taxLoading = true
		return m, func() tea.Msg {
			if _, err := m.client.CreateTaxonomy(kind, input); err != nil {
				return errMsg{err}
			}
			return taxonomyActionDoneMsg{}
		}
	case taxPromptEditName:
		name := strings.TrimSpace(m.taxPromptBuf)
		if name == "" {
			m.taxPromptMode = taxPromptNone
			m.taxPromptBuf = ""
			return m, func() tea.Msg { return errMsg{fmt.Errorf("taxonomy name required")} }
		}
		m.taxPendingName = name
		m.openTaxPrompt(taxPromptEditDescription, m.taxPendingDesc)
		return m, nil
	case taxPromptEditDescription:
		name := m.taxPendingName
		desc := strings.TrimSpace(m.taxPromptBuf)
		id := m.taxEditID
		kind := m.taxonomyKindPath()
		m.taxPromptMode = taxPromptNone
		m.taxPromptBuf = ""
		m.taxPendingName = ""
		m.taxPendingDesc = ""
		m.taxEditID = ""
		m.taxLoading = true
		return m, func() tea.Msg {
			_, err := m.client.UpdateTaxonomy(kind, id, api.UpdateTaxonomyInput{
				Name:        &name,
				Description: &desc,
			})
			if err != nil {
				return errMsg{err}
			}
			return taxonomyActionDoneMsg{}
		}
	case taxPromptFilter:
		m.taxSearch = strings.TrimSpace(m.taxPromptBuf)
		m.taxPromptMode = taxPromptNone
		m.taxPromptBuf = ""
		m.taxLoading = true
		return m, m.loadTaxonomy
	default:
		return m, nil
	}
}

func (m ProfileModel) taxonomyArchiveSelected() (ProfileModel, tea.Cmd) {
	item := m.selectedTaxonomy()
	if item == nil {
		return m, nil
	}
	kind := m.taxonomyKindPath()
	m.taxLoading = true
	return m, func() tea.Msg {
		if _, err := m.client.ArchiveTaxonomy(kind, item.ID); err != nil {
			return errMsg{err}
		}
		return taxonomyActionDoneMsg{}
	}
}

func (m ProfileModel) taxonomyActivateSelected() (ProfileModel, tea.Cmd) {
	item := m.selectedTaxonomy()
	if item == nil {
		return m, nil
	}
	kind := m.taxonomyKindPath()
	m.taxLoading = true
	return m, func() tea.Msg {
		if _, err := m.client.ActivateTaxonomy(kind, item.ID); err != nil {
			return errMsg{err}
		}
		return taxonomyActionDoneMsg{}
	}
}

func (m ProfileModel) renderTaxonomy() string {
	var b strings.Builder

	kindTabs := make([]string, 0, len(taxonomyKinds))
	for i, kind := range taxonomyKinds {
		if i == m.taxKind {
			kindTabs = append(kindTabs, SelectedStyle.Render(kind.Label))
		} else {
			kindTabs = append(kindTabs, MutedStyle.Render(kind.Label))
		}
	}
	b.WriteString(components.CenterLine(strings.Join(kindTabs, "   "), m.width))
	b.WriteString("\n\n")

	if m.taxPromptMode != taxPromptNone {
		return b.String() + components.Indent(
			components.InputDialog(m.taxonomyPromptTitle(), m.taxPromptBuf),
			1,
		)
	}

	if m.taxLoading {
		return b.String() + components.Indent(
			components.Box(MutedStyle.Render("Loading taxonomy..."), m.width),
			1,
		)
	}

	if len(m.taxItems) == 0 {
		return b.String() + components.Indent(
			components.Box(MutedStyle.Render("No taxonomy rows found."), m.width),
			1,
		)
	}

	contentWidth := components.BoxContentWidth(m.width)
	visible := m.taxList.Visible()

	filterText := m.taxSearch
	if filterText == "" {
		filterText = "-"
	}
	info := fmt.Sprintf(
		"%d rows  ·  include inactive: %t  ·  filter: %s",
		len(m.taxItems),
		m.taxIncludeInactive,
		filterText,
	)

	previewWidth := contentWidth * 35 / 100
	if previewWidth < 40 {
		previewWidth = 40
	}
	if previewWidth > 60 {
		previewWidth = 60
	}

	gap := 3
	tableWidth := contentWidth
	sideBySide := contentWidth >= 110
	if sideBySide {
		tableWidth = contentWidth - previewWidth - gap
		if tableWidth < 60 {
			sideBySide = false
			tableWidth = contentWidth
		}
	}

	sepWidth := 1
	if br := lipgloss.RoundedBorder().Left; br != "" {
		sepWidth = lipgloss.Width(br)
	}

	// 3 columns -> 2 separators.
	availableCols := tableWidth - (2 * sepWidth)
	if availableCols < 30 {
		availableCols = 30
	}

	flagsWidth := 14
	descWidth := 30
	nameWidth := availableCols - (flagsWidth + descWidth)
	if nameWidth < 14 {
		nameWidth = 14
		descWidth = availableCols - (nameWidth + flagsWidth)
		if descWidth < 14 {
			descWidth = 14
		}
	}

	cols := []components.TableColumn{
		{Header: "Name", Width: nameWidth, Align: lipgloss.Left},
		{Header: "Flags", Width: flagsWidth, Align: lipgloss.Left},
		{Header: "Description", Width: descWidth, Align: lipgloss.Left},
	}

	tableRows := make([][]string, 0, len(visible))
	activeRowRel := -1
	var previewItem *api.TaxonomyEntry
	if idx := m.taxList.Selected(); idx >= 0 && idx < len(m.taxItems) {
		previewItem = &m.taxItems[idx]
	}

	for i := range visible {
		absIdx := m.taxList.RelToAbs(i)
		if absIdx < 0 || absIdx >= len(m.taxItems) {
			continue
		}
		item := m.taxItems[absIdx]

		name := strings.TrimSpace(components.SanitizeOneLine(item.Name))
		if name == "" {
			name = "-"
		}
		flags := []string{}
		if item.IsBuiltin {
			flags = append(flags, "builtin")
		}
		if !item.IsActive {
			flags = append(flags, "inactive")
		}
		flagText := "-"
		if len(flags) > 0 {
			flagText = strings.Join(flags, ", ")
		}

		desc := "-"
		if item.Description != nil && strings.TrimSpace(*item.Description) != "" {
			desc = strings.TrimSpace(*item.Description)
		}

		if m.taxList.IsSelected(absIdx) {
			activeRowRel = len(tableRows)
		}
		tableRows = append(tableRows, []string{
			components.ClampTextWidthEllipsis(name, nameWidth),
			components.ClampTextWidthEllipsis(flagText, flagsWidth),
			components.ClampTextWidthEllipsis(components.SanitizeOneLine(desc), descWidth),
		})
	}

	table := components.TableGridWithActiveRow(cols, tableRows, tableWidth, activeRowRel)
	preview := ""
	if previewItem != nil {
		content := m.renderTaxonomyPreview(*previewItem, previewBoxContentWidth(previewWidth))
		preview = renderPreviewBox(content, previewWidth)
	}

	body := table
	if sideBySide && preview != "" {
		body = lipgloss.JoinHorizontal(lipgloss.Top, table, strings.Repeat(" ", gap), preview)
	} else if preview != "" {
		body = table + "\n\n" + preview
	}

	content := MutedStyle.Render(info) + "\n\n" + body + "\n"
	title := fmt.Sprintf("%s Taxonomy", taxonomyKinds[m.taxKind].Label)
	return b.String() + components.Indent(components.TitledBox(title, content, m.width), 1)
}

func (m ProfileModel) renderTaxonomyPreview(item api.TaxonomyEntry, width int) string {
	if width <= 0 {
		return ""
	}

	title := strings.TrimSpace(components.SanitizeOneLine(item.Name))
	if title == "" {
		title = "taxonomy"
	}

	status := "active"
	if !item.IsActive {
		status = "inactive"
	}

	var lines []string
	lines = append(lines, MetaKeyStyle.Render("Selected"))
	for _, part := range wrapPreviewText(title, width) {
		lines = append(lines, SelectedStyle.Render(part))
	}
	lines = append(lines, "")

	lines = append(lines, renderPreviewRow("Status", status, width))
	if item.IsBuiltin {
		lines = append(lines, renderPreviewRow("Builtin", "true", width))
	}
	lines = append(lines, renderPreviewRow("ID", shortID(item.ID), width))
	if item.Description != nil && strings.TrimSpace(*item.Description) != "" {
		lines = append(lines, renderPreviewRow("Desc", strings.TrimSpace(*item.Description), width))
	}
	if item.IsSymmetric != nil {
		lines = append(lines, renderPreviewRow("Symmetric", fmt.Sprintf("%t", *item.IsSymmetric), width))
	}
	if metaPreview := metadataPreview(map[string]any(item.Metadata), 80); metaPreview != "" {
		lines = append(lines, renderPreviewRow("Meta", metaPreview, width))
	}

	return padPreviewLines(lines, width)
}
